{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Nahuel/Documents/Proyectos/PAngular-master/PAngular-master/ecommersGB/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Observable } from 'rxjs';\nimport { ref, onValue, off, get, set, update } from 'firebase/database';\nimport { getFirebase } from '../firebase.init';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./auth.service\";\nexport let FacturaService = /*#__PURE__*/(() => {\n  class FacturaService {\n    constructor(auth) {\n      this.auth = auth;\n      this.ROOT = 'facturas';\n    }\n    /** Observa todas las facturas (ordenadas por ts desc) */\n    facturas$() {\n      return new Observable(sub => {\n        // Traemos la instancia de RTDB y nos suscribimos con onValue\n        getFirebase().then(({\n          database\n        }) => {\n          const r = ref(database, this.ROOT);\n          const handler = snap => {\n            const val = snap.val() || {};\n            const arr = Object.entries(val).map(([id, f]) => this.mapFactura(id, f));\n            sub.next(arr.sort((a, b) => b.ts - a.ts));\n          };\n          onValue(r, handler, err => sub.error(err));\n          // Teardown de la suscripciÃ³n\n          sub.add(() => off(r, 'value', handler));\n        }).catch(err => sub.error(err));\n      });\n    }\n    /** Lee todas las facturas una vez */\n    facturasOnce() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const {\n          database\n        } = yield getFirebase();\n        const r = ref(database, _this.ROOT);\n        const snap = yield get(r);\n        const val = snap.val() || {};\n        const arr = Object.entries(val).map(([id, f]) => _this.mapFactura(id, f));\n        return arr.sort((a, b) => b.ts - a.ts);\n      })();\n    }\n    /** Crea una factura tomando SIEMPRE el usuario actual */\n    crearFactura(payload) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        const now = Date.now();\n        const id = `${now}-${Math.random().toString(36).slice(2, 8)}`;\n        // ðŸ”„ Esperar a que se resuelva el usuario actual\n        const usuario = yield _this2.auth.getUsuarioActual();\n        const userId = usuario?.uid ?? null;\n        const cliente_email = usuario?.email ?? null;\n        const cliente_nombre = usuario?.displayName ?? usuario?.email ?? null;\n        const factura = {\n          ts: now,\n          fechaISO: new Date(now).toISOString(),\n          totalARS: payload.totalARS,\n          totalUSD: payload.totalUSD,\n          tipo_cambio: payload.tipo_cambio,\n          estado: 'PAGADA',\n          userId,\n          cliente_email,\n          cliente_nombre,\n          items: payload.items ?? []\n        };\n        const {\n          database\n        } = yield getFirebase();\n        yield set(ref(database, `${_this2.ROOT}/${id}`), factura);\n        return id;\n      })();\n    }\n    /** Actualiza el estado de una factura */\n    actualizarEstado(id, estado) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        const {\n          database\n        } = yield getFirebase();\n        yield update(ref(database, `${_this3.ROOT}/${id}`), {\n          estado\n        });\n      })();\n    }\n    /** CSV simple para exportar (incluye columna Detalle) */\n    generarCSVDesdeFacturas(facturas) {\n      const headers = ['ID', 'Fecha', 'Total_ARS', 'Total_USD', 'Tipo_Cambio', 'Estado', 'Cliente_Email', 'Cliente_Nombre', 'Detalle' // <- NUEVA COLUMNA\n      ];\n      const rows = facturas.map(f => [f.id, this.formatFechaLocal(f.ts), this.formatMoneyARS(f.totalARS), f.totalUSD != null ? this.formatMoneyUSD(f.totalUSD) : '', f.tipo_cambio ?? '', f.estado, f.cliente_email ?? '', f.cliente_nombre ?? '', this.buildDetalle(f) // <- TEXTO CONCATENADO DE ITEMS\n      ]);\n      const csv = [headers, ...rows].map(r => r.map(v => this.csvEscape(String(v ?? ''))).join(',')).join('\\n');\n      return new Blob([csv], {\n        type: 'text/csv;charset=utf-8;'\n      });\n    }\n    // ---------- helpers ----------\n    csvEscape(s) {\n      if (s.includes('\"') || s.includes(',') || s.includes('\\n')) {\n        return `\"${s.replace(/\"/g, '\"\"')}\"`;\n      }\n      return s;\n    }\n    formatFechaLocal(ts) {\n      try {\n        return new Date(ts).toLocaleString();\n      } catch {\n        return '';\n      }\n    }\n    formatMoneyARS(n) {\n      try {\n        return new Intl.NumberFormat('es-AR', {\n          style: 'currency',\n          currency: 'ARS',\n          maximumFractionDigits: 2\n        }).format(n);\n      } catch {\n        return String(n);\n      }\n    }\n    formatMoneyUSD(n) {\n      try {\n        return new Intl.NumberFormat('en-US', {\n          style: 'currency',\n          currency: 'USD',\n          maximumFractionDigits: 2\n        }).format(n);\n      } catch {\n        return String(n);\n      }\n    }\n    mapFactura(id, f) {\n      return {\n        id,\n        ts: Number(f?.ts ?? 0),\n        fechaISO: String(f?.fechaISO ?? ''),\n        totalARS: Number(f?.totalARS ?? 0),\n        totalUSD: f?.totalUSD ?? null,\n        tipo_cambio: f?.tipo_cambio ?? null,\n        estado: f?.estado ?? 'PAGADA',\n        userId: f?.userId ?? null,\n        cliente_email: f?.cliente_email ?? null,\n        cliente_nombre: f?.cliente_nombre ?? null,\n        items: f?.items ?? undefined\n      };\n    }\n    /** Arma el texto \"Detalle\" a partir de los items de la factura */\n    buildDetalle(f) {\n      const items = Array.isArray(f?.items) ? f.items : [];\n      if (!items.length) return '';\n      const fmt = n => {\n        const x = Number(n);\n        return isNaN(x) ? '' : x.toFixed(2);\n      };\n      // FacturaItem: producto_nombre, cantidad, precio_unitario, subtotal_ars\n      return items.map(it => {\n        const nombre = it.producto_nombre ?? '(sin nombre)';\n        const cantidad = Number(it.cantidad ?? 1);\n        const unit = Number(it.precio_unitario ?? 0);\n        const subtotal = it.subtotal_ars != null ? Number(it.subtotal_ars) : unit * (isNaN(cantidad) ? 0 : cantidad);\n        const subTxt = isNaN(subtotal) ? '' : subtotal.toFixed(2);\n        return `${nombre} x${isNaN(cantidad) ? '' : cantidad} @${fmt(unit)} = ${subTxt}`;\n      }).join(' | ');\n    }\n    static {\n      this.Éµfac = function FacturaService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || FacturaService)(i0.ÉµÉµinject(i1.AuthService));\n      };\n    }\n    static {\n      this.Éµprov = /*@__PURE__*/i0.ÉµÉµdefineInjectable({\n        token: FacturaService,\n        factory: FacturaService.Éµfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return FacturaService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}